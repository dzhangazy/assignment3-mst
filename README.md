ğŸ§® Assignment 3 â€” Minimum Spanning Tree (MST)
Course: Object-Oriented Programming / Algorithms & Data Structures
Topic: Comparison of Primâ€™s and Kruskalâ€™s Algorithms
Author: Jangazy Bakytzhan
Language: Java (Maven Project)
IDE: Visual Code
ğŸ“ Project Structure
assignment3-mst/
â”‚
â”œâ”€â”€ src/
â”‚ â”œâ”€â”€ main/java/mst/
â”‚ â”‚ â”œâ”€â”€ Edge.java
â”‚ â”‚ â”œâ”€â”€ Graph.java
â”‚ â”‚ â”œâ”€â”€ PrimAlgorithm.java
â”‚ â”‚ â”œâ”€â”€ KruskalAlgorithm.java
â”‚ â”‚ â”œâ”€â”€ MSTMain.java
â”‚ â”‚ â””â”€â”€ Utils.java
â”‚ â”œâ”€â”€ main/resources/
â”‚ â”‚ â”œâ”€â”€ input.json
â”‚ â”‚ â””â”€â”€ output.json
â”‚
â”œâ”€â”€ analyze_results.py â† Empirical validation script (Python)
â”œâ”€â”€ empirical_validation.png â† Final comparative plot
â””â”€â”€ README.md â† This report

âš™ï¸ Project Overview

The goal of this assignment is to implement and compare two classical algorithms for building a Minimum Spanning Tree (MST):

Primâ€™s Algorithm

Kruskalâ€™s Algorithm

Both algorithms are applied to multiple input graphs (loaded from input.json).
For each graph, the algorithms compute:

The resulting MST edges,

The total cost of the MST,

The number of internal operations,

The execution time (in milliseconds).

All results are stored in output.json for further analysis and empirical validation.

ğŸ§© Input and Output Format
input.json

Contains multiple graphs, each with a list of vertices and edges.

Example:

{
"graphs": [
{
"id": 1,
"vertices": ["A", "B", "C", "D", "E"],
"edges": [
{"from": "A", "to": "B", "weight": 3},
{"from": "B", "to": "C", "weight": 2},
{"from": "A", "to": "C", "weight": 4},
{"from": "C", "to": "E", "weight": 6}
]
}
]
}

output.json

Contains computed MST results for each graph.

Example:

{
"results": [
{
"graph_id": 1,
"input_stats": {"vertices": 5, "edges": 7},
"prim": {
"total_cost": 16,
"operations_count": 42,
"execution_time_ms": 1.52
},
"kruskal": {
"total_cost": 16,
"operations_count": 37,
"execution_time_ms": 1.28
}
}
]
}

ğŸ§  Algorithm Description
Primâ€™s Algorithm

Starts from an arbitrary vertex.

Repeatedly adds the smallest-weight edge that connects a new vertex to the growing MST.

Time complexity:

Using adjacency matrix: O(VÂ²)

Using min-heap (priority queue): O(E log V)

Kruskalâ€™s Algorithm

Sorts all edges by weight.

Iteratively adds the smallest edge that does not form a cycle (using DSU/Union-Find).

Time complexity: O(E log E) â‰ˆ O(E log V)

ğŸ§ª Empirical Validation

To compare algorithms empirically, we generated 5â€“6 random graphs of increasing size
and measured:

Execution time (ms)

Number of operations

Total MST cost

Metrics
Metric Description Purpose
execution_time_ms Wall-clock time of algorithm execution Performance
operations_count Internal iteration or comparison count Computational effort
total_cost Sum of MST edge weights Correctness validation
ğŸ“Š Results Visualization

The script analyze_results.py reads output.json and plots three comparative graphs:

Graph Description
â± Execution Time vs Vertices Shows which algorithm performs faster empirically
âš™ï¸ Operations Count vs Vertices Shows efficiency in number of operations
ğŸ’° Total Cost Confirms both algorithms produce the same MST

Final plot:
ğŸ“ empirical_validation.png

ğŸ§© Observations
Metric Observation
Execution Time Kruskal tends to perform slightly faster on small dense graphs; Prim becomes comparable on larger, sparser graphs.
Operations Count Both show roughly linearâ€“logarithmic growth, consistent with theoretical O(E log V).
Total Cost Identical for both algorithms â€” confirms correctness of implementation.
ğŸ“ˆ Empirical Graph (from output.json)

Below is the actual result generated by analyze_results.py:

ğŸ§© Conclusion

Both algorithms successfully compute the same MST, validating their correctness.
Empirical validation confirms:

Kruskalâ€™s algorithm performs slightly faster for smaller graphs.

Primâ€™s algorithm scales well for larger or sparse graphs.

The observed growth matches expected O(E log V) complexity.

Thus, both implementations are efficient and consistent with theoretical expectations.

ğŸ’¾ How to Run
Build (Maven)
mvn compile

Run Main Program
mvn exec:java -Dexec.mainClass=mst.MSTMain

Generate Plots
python analyze_results.py

Output:

âœ… Empirical validation plot saved as 'empirical_validation.png'

ğŸ§° Technologies Used
Tool Purpose
Java (JDK 17) Implementation of algorithms
Maven Build & dependency management
JSON.simple JSON parsing
Python + Matplotlib Empirical visualization
GitHub Version control & submission
ğŸ Summary

This project demonstrates:

Implementation of two MST algorithms (Prim & Kruskal),

Structured JSON-based data I/O,

Automated testing and performance measurement,

Full empirical validation with visual analysis.

Both algorithms produce identical MST results and exhibit predictable complexity trends, confirming both correctness and expected efficiency.
